`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 10/16/2025 08:58:28 AM
// Design Name: 
// Module Name: uart_rx
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module uart_rx(
        input clk,
        input rst,
        input RsRx,
        output reg [7:0] rx_data,
        output reg valid
);

localparam DATA_BITS = 8,
           BAUD_RATE = 9600,
           DIV_SAMPLE = 16,
           MID_SAMPLE = DIV_SAMPLE / 2,
           CLK_FREQ = 100_000_000;

wire baudx16;

uart_baud_gen #(
    .BAUD_RATE(BAUD_RATE),
    .CLK_FREQ(CLK_FREQ),
    .OVERSAMPLE(DIV_SAMPLE)
) baud_gen (
    .clk(clk),
    .rst(rst),
    .baud(baudx16)
);
    




localparam  IDLE = 3'b000,
            START = 3'b001,
            DATA = 3'b010,
            STOP = 3'b011,
            ERROR = 3'b100;

wire start_bit_detected;
wire half_bit_elapsed;
wire last_data_recieved;

(* fsm_safe_state = "reset_state" *) reg [2:0] state;
reg [2:0] next_state;
reg [3:0] bit_counter;
reg [3:0] sample_counter;


assign start_bit_detected = !RsRx;
assign half_bit_elapsed = sample_counter == (MID_SAMPLE - 1);
assign last_data_recieved = bit_counter == (DATA_BITS);

always @(*) begin
    case(state)
        IDLE: next_state <= start_bit_detected ?  START : IDLE;
        START: next_state <= (sample_counter == DIV_SAMPLE - 1) ?  DATA : START;
        DATA: next_state <= last_data_recieved ? STOP : DATA;
        STOP: next_state <= half_bit_elapsed ? IDLE : STOP;
        default: next_state <= IDLE;
    endcase
end

always @(posedge clk) begin
    if (rst) begin
        state <= IDLE;
    end
    else state <= next_state;
end
    
always @(posedge baudx16) begin
    case (state)
        // Like a reset state, but these variables are just for counting
        IDLE: begin
            bit_counter <= 0;
            sample_counter <= 0;
        end
        START: begin
            sample_counter <= sample_counter + 1;
            bit_counter <= 0;
            rx_data <= 0;
        end
        DATA: begin
            sample_counter <= sample_counter + 1;
            if (half_bit_elapsed) begin
                rx_data[bit_counter] <= RsRx;
                bit_counter <= bit_counter + 1;
            end
        end
        STOP: begin
            sample_counter <= sample_counter + 1;
            // check stop bit, mark valid if high. Go to error and do other stuff otherwise.
        end
        default: ; //error probably
    endcase
end
    
endmodule
